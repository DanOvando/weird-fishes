---
title: "Practical purrr"
author: "Dan Ovando"
date: '2018-02-13'
slug: practical-purrr
tags:
- purrr
- R
- tidyverse
categories: R
type: post
---

```{r setup, include=FALSE}
set.seed(123)
knitr::opts_chunk$set(echo = TRUE)
library(purrr)
library(repurrrsive)
library(stringr)
library(ggthemes)
library(gapminder)
library(modelr)
library(extrafont)
library(tidyverse)
extrafont::loadfonts(quiet = T)


pres_theme <- theme_fivethirtyeight(base_size = 16, 
                                    base_family = 'Arial Narrow') + 
  theme(axis.title = element_text())
theme_set(pres_theme)

```

The goal of this workshop and document is to get you familiar with the workings of the `purrr` package. There's of course a lot more than can be covered here, but hopefully this should get you familiar with

1. Using `purrr` as a replacement for `apply`

2. Using `purrr` to wrangle lists

3. Using `purrr` for data analysis

Full credit to Jenny Bryan's [excellent `purrr` tutorial](https://jennybc.github.io/purrr-tutorial/) for many of the ideas here, along with Hadley Wickham & Garret Grolemund's [R for Data Science](http://r4ds.had.co.nz). My goal is to walk you through some of the concepts outlined in these (much better) resources, and expand on some particular applications that have been useful to me.

## What is `purrr`?

`purrr` is a part of the tidyverse, taking on the tasks accomplished by the `apply` suite of functions in base R (and a whole lot more). It's great at applying operations across many dimensions of your data, improving your ability to keep even complex analyses "tidy". At it's simplest, it's just another way to use `apply`. At its most complex, it allows you to easily move around in and manipulate multi-dimensional (and multi-type) data.

There are a whole suite of functions involved with `purrr`, but the goal of this tutorial is to get the fundamentals down so that you can start incorporating `purrr` into your own code and explore higher-level abilities on your own.

## Why not loops?

Let's start with this PSA: **loops aren't always bad!**

For some problems (e.g. population models, or really any dynamic process where the current state depends on past states), loops are really the simplest option. 

For other problems, things might work a little faster if you used something like `purrr`, but the amount of time required to set it up might not be worth it. 

The reason to move away from loops is when doing so really helps you solve a problem, not when it makes your code look fancier. 

To work backwords then, `apply`, and `map` basically take on the tasks of a `for` loop

$$2 + \beta$$

```{r}

shades <- colors()[1:10]

for (i in seq_along(shades)){
  
  print(shades[i])
  
}

```

using apply
```{r}

a <-  lapply(shades, print)

```

using `map`

```{r}

a <-  map(shades, print)

```

This is obviously a trivial example, but you get the idea: these are three ways applying a function to a vector/list of things.


The (main) advantages of using things like `apply` or `map` in my experience are that they

1. Allow you to easily escape writing nested for loops

2. Don't require you to pre-allocate space 

3. Can be easily plugged into other more complex operations (e.g. in a pipe)

4. Can be easier to read

### Key verbs

`map` is the workhorse of the `purrr` family. It is basically `apply`

  - The basic syntax:

  - `map("Lists to apply function to","Function to apply across lists","Additional parameters")`

Since a dataframe is basically a special case of a list in which all entries have the same number of rows, we can `map` through each element (column in thise case) of say `mtcars`

```{r}

map(mtcars, mean, na.rm = T)

```

  - `map` by default returns a list

  - `map_TYPE` returns an object of class TYPE, e.g.

    - `map_lgl` returns logical objects

    - `map_df` returns data frames, etc.

Specifying type makes it easier to wrangle different types of outputs

`map` can also be extended to deal with multiple input lists

  - `map` applies a function over one list.

  - `map2` applies a function over combinations of two lists in the form

    - `map2(list1, list2, ~function(.x,.y), ...)`

```{r}

map2_chr(c('one','two','red','blue'), c('fish'), paste)

```

`purrr` is smart enough to help you with some basic stuff, like guessing that I'm trying to do with paste here. A lot of times that won't work and you have to be more specific though. In this example, we can do the exact same thing with


```{r}

map2_chr(c('one','two','red','blue'), c('fish'), ~paste(.x,.y))

```

Note here I've used `~` to define one-sided formula on the fly, which is handy for simple things like this. We'll see later how to write and use longer functions here. 

Anything above two lists is handled by `pmap`. `pmap` allows you to pass an arbitraty number of objects to map, where each object is a named element in a list, and the function takes matching elements of those lists as entries

```
pmap(list(list1,list2,list3), function(list1, list2, list3),...)

```
 
Getting used to using `map` is the foundation to working with `purrr`.

We'll now go into more detail on ways to use this in a practical way.

To bring this part together, here are three ways of doing the exact same thing; checking to see if both of the columns in a row are NA

```{r}

x <- c(1,1,NA,NA)

y <-  c(1, NA, 1, NA)

z <-  data_frame(x = x, y = y)

nafoo <- function(x,y){
  
out <- (is.na(x) & is.na(y))

}

```

```{r}
z %>%
mutate(both_na = map2_lgl(x,y,nafoo))
```

```{r}
z %>%
mutate(both_na = map2_lgl(x,y, ~ is.na(.x) & is.na(.y)))
```

```{r}
z %>%
mutate(both_na = pmap_lgl(list(x = x,y = y), nafoo))
```


## Functional programming


`purrr` is designed to help with "functional programming", which you can take broadly as trying to use functions (preferably "pure" ones) to accomplish most of your complex and repetitive tasks (don't copy and paste more then 3 times - H. Wickham)

As a very quick reintroduction to functions:

  Functions in R take any number of named inputs, do operations on them, and returns the last thing produced inside the function (or whatever you specify using `return`)

```{r}

z <- 10

foo <- function(x,y) {

  z <- x + y

  return(z)
}

foo(x = 2,y = 3)

z
```

Notice that `z` wasn't affected by the `z` inside the function. Operations inside functions happen in the local environment of that function. "What happens in the function, stays in the function (except what you share via `return`)"

Note though that functions can "see" objects in the global environment

```{r}

a <- 10

foo <- function(x,y) {

z <- x + y + a

return(z)
}

foo(x = 2, y = 3)


```

I strongly recommend you avoid relying on global variables inside functions: it can very easily cause unintended and sneaky behavior.

Functions can be as complicated as you want them to be, but a good rule is to try and make sure each function is good at doing *one* thing. That doesn't mean that that "one thing" can't be a complex series of operation, but the objective of the function should be to do that one thing well. 

You can also use "anonymous" functions in R/`purrr`. This is basically a shortcut for when you don't want to take up the space of writing and saving a whole function somewhere. You make anonymous functions with `~`

Say you want the coefficient of variation of each of the variables in `mtcars`


```{r}

cvfoo <- function(x){

  sd(x) / mean(x)

}

map(mtcars, cvfoo)

```

Can be accomplished using

```{r}

map(mtcars, ~ sd(.) / mean(.))

```

Notice the rather confusing `.` in there. `.` basically is a marker for whatever data is passed to a function/thing in R.

```{r}
mtcars %>%  {
  .$mpg
}
```

The `{` after the pipe tells R that the things inside the brackets don't take the data passed to it as its first argument

## Wrangling lists

Now that we have an idea of how we can use `purrr`, let's get back to actually using `purrr` in practice.

Lists are powerful objects that allow you to store all kinds of information in one place.

They can also be a pain to deal with, since we are no longer in the nice 2-D structure of a traditional dataframe, which is much closer to how most of us probably leared to deal with data. 

`purrr` has all kinds of useful tools for helping you quickly and efficiently poke around inside lists. Let's start with the Game of Thrones database in the `repurrrsive` package. This is a list containing a bunch of information on GoT characters with a "point of view" chapter in the first few books. 

The `str` function is a great way to get a first glimpse at a list's structure


```{r}

str(got_chars, list.len =  3)

```


For those of you who prefer a more interactive approach, you can also use the `jsonedit` function in the `listviewer` package



```{r}

listviewer::jsonedit(got_chars)

```


So, how do we start poking around in this database?

Suppose we wanted only the first 5 characters in the list


```{r}

got_chars[1:5] %>% 
  str(max.level = 1)

```

Now, suppose that we jut want to look at the name of the first 5 characters. Who remembers how to do this in base R?

You might think that `got_chars[[1:5]]$name` would do the trick...

```{r, error = T}
got_chars[[1:5]]$name
```

Nope.

So we could do

```{r}

names <- vector(mode = "character",5)

for (i in 1:5){
  
  names[i] <- got_chars[[i]]$name
}

names

```
That works, but certainly not ideal.

Enter `purrr`

```{r}

got_chars[1:5] %>%
  map_chr('name')

```

Nice! `map` figures that when you do this, you're looking for that list entry. I actually find some of the "helps" a bit confusing when you're learning, since they play by slightly different rules than the `purrr` functions usually do. Case in point, given the above example, how do we think we might get the 'name' and 'allegiances' columns?


```{r}

got_chars[1:5] %>%
  map(c('name','allegiances')) 

```


Huh, why didn't that work? `purrr` has some built in helpers for simple operations, but as things get more complicated you need to specify functions


```{r}
got_chars[1:5] %>%
  map(`[`, c('name', 'allegiances'))

```

In this case, `[` is saying use `[]` as a function.

One more example, let's say you've got a list that goes a little deeper. Suppose that we want to extract element `w` from the list `thing` as characters. We can spell out the path that we want `purrr` to go through using `c("z","w")`, which tells `purrr` to first to to `z`, then `w`, and return `w`.

```{r}

thing <- list(list(y = 2, z = list(w = 'hello')),
              list(y = 2, z = list(w = 'world')))

map_chr(thing, c('z','w'))

```

If you're like me, the numeric indexing of each of the entries is currently driving you nuts: I'd rather have each element in the list be named by the character it refers to. I can use `set_names


```{r}

got_chars[1:5] %>%
  rlang::set_names(map_chr(.,'name')) %>%
  listviewer::jsonedit()

```


Much better! 

Now, let's say that I want to get all the Lanisters, so I can see which people to hate.

This is where a lot of the power of `purrr` starts to come in, allowing you to easily apply functions across nested layers of a list


```{r}
got_chars %>%
  set_names(map_chr(.,'name')) %>%
  map(`[`,c('name','allegiances')) %>%
  purrr::keep(~stringr::str_detect(.$name, 'Lannister')) %>%
  listviewer::jsonedit()
```


Now, suppose that we want anyone who's allied with the Starks


```{r}
got_chars[1:4] %>%
set_names(map_chr(.,'name')) %>%
map(`[`,c('name','allegiances')) %>% 
map(~str_detect(.$allegiances, 'Stark'))
  
```


Hmmm, that doesn't look good, what's up with Will? What happens if I try and use `keep` (list `filter`) here?


```{r, eval = F,error = T}

got_chars %>%
set_names(map_chr(.,'name')) %>%
map(`[`,c('name','allegiances')) %>%
keep(~str_detect(.$allegiances, 'Stark'))

```


Nope that still doesn't work. What's going on? The problem here is that our friend Will has no allegiances, and worse yet, the allegiances entry doesn't say "none", it's just an empty array. Here's one way to solve this


```{r}

got_chars %>%
set_names(map_chr(.,'name')) %>%
map(`[`,c('name','allegiances')) %>%
keep(~ifelse(length(.$allegiances) > 0, str_detect(.$allegiances, 'Stark'),FALSE)) %>%
listviewer::jsonedit()

```

There's almost certainly a better way, but this just shows that things get a little more complicated when you're trying to apply functions across list objects; things like dimensions, types, NULLs, can cause problems. If I'm trying something new, I'll usually try and develop the methods on a subset of the list that I know is "ideal", make sure it works there, and then try the operation on progressively more complicated lists. That allows me to separate errors in my functions vs. problems reading in "odd" data types.


As Cersei likes to remind us, anyone who's not a Lannister is an enemy to the Lannisters. Let's look at all the POV characters that aren't allied to the Lannisters


```{r}
got_chars %>%
  set_names(map_chr(.,'name'))  %>%
  map(`[`,c('name','allegiances')) %>%
  discard(~ifelse(length(.$allegiances) > 0, str_detect(.$allegiances, 'Lannister'),FALSE)) %>%
  listviewer::jsonedit()

```


You can also use `map` together with your own custom functions. Suppose we wanted to figure out how many aliases and alliances each character has, as well as where they were born. We can use `pmap` to apply a function over each of these attributes


```{r}

got_list <- got_chars %>%
  map(`[`, c('name','aliases','allegiances','born'))

got_list <-  got_chars %>% {
  list(
    name = map_chr(.,'name'),
    aliases = map(.,'aliases'),
    allegiances = map(.,'allegiances'),
    born = map_chr(.,'born')
  )
}

str(got_list, list.len = 3)

got_foo <- function(name, aliases, allegiances,born){

  paste(name, 'has', length(aliases), 'aliases and', length(allegiances),
        'allegiances, and was born in', born)

}

got_list %>%
  pmap_chr(got_foo) %>%
  head()

```


Things obviously get a lot more complicated than this, but hopefully that gives you an idea of how to manipulate lists using `purrr`


```{r}

got_chars %>%
  set_names(map_chr(.,'name'))  %>%
  map(`[`,c('name','allegiances')) %>%
  listviewer::jsonedit()

```


## Analysis with `purrr` and `modelr`

So far, `purrr` has basically helped us use tidy operations on lists. That's nice, but its real power comes in helping with analysis. Let's look at the gapminder data set

```{r}

head(gapminder)
```



```{r, echo = F}

gapminder::gapminder %>%
  ggplot(aes(year,lifeExp, color = country)) +
  geom_line(show.legend = F) +
  facet_wrap(~continent) +
  labs(title = 'Life expectancy across continents')

```


Now, suppose we want to build up a model trying to predict life expectancy as a function of covariates, starting with a simple one: life expectancy as a function of population and per capita GDP


```{r}

gapminder <- gapminder %>%
  set_names( colnames(.) %>% tolower())

life_mod <- lm(lifeexp ~ pop + gdppercap, data = gapminder)

```



```{r, results = 'asis', echo = F}

stargazer::stargazer(life_mod, type = 'html')

```


Not bad for a simple model, but how do we know if this is the model we want to use? Let's use AIC to compare a few different model structures (note, this is not an endorsement for AIC mining!)


```{r}

m1 <- 'lifeexp ~ pop + gdppercap'

m2 <- 'lifeexp ~ pop + gdppercap + continent + year'

m3 <- 'lifeexp ~ pop + gdppercap + country + year'

m4 <- 'lifeexp ~ pop + gdppercap + year*country'

```


Now, since this is a simple three model example, we could just use a loop, or even copy and paste a few times. But, let's see how we can use `purrr` to help us do some diagnostics on these models.


Let's start by getting our models and data into a data frame, using list-columns

```{r}

model_frame <- data_frame(model = c(m1, m2, m3,m4)) %>%
mutate(model = map(model, as.formula))

```


First, let's use purrr to convert each of these character strings into a model


```{r}

model_frame <- data_frame(model_name = c('simple','medium','more', 'woah'),model = list("simple" = m1, 'medium' = m2, 'more' = m3, 'woah' = m4)) %>%
  mutate(model = map(model, as.formula))

model_frame
```


```{r, eval = F}

model_frame <- model_frame %>%
  mutate(fit = lm(model, data = gapminder))

```


Hmmm, why didn't that work? `mutate` by itself doesn't know how to evaluate this, but `map` can help us out


```{r}
model_frame <- model_frame %>%
  mutate(fit = map(model, ~lm(., data = gapminder)))

model_frame
```


We're now going to start integrating some methods from the `modelr` package to diagnose our regression


```{r}
model_frame <- model_frame %>%
mutate(r2 = map_dbl(fit, ~rsquare(., data = gapminder)),
aic = map_dbl(fit, ~AIC(.)))

model_frame

```


So, AIC tells us that our über complicated model is still the most parsimonious. Let's dig into this a bit further, by explicitly testing the out of sample predictive ability of each of the models. "Overfit" models are commonly really good at describing the data that they are fit to, but perform poorly out of sample.


We'll start by using the `modelr` package to create a bunch of training-test combination data sets


```{r}


validate <- gapminder %>%
crossv_mc(20, test = 0.25)

test_data <- list(test_training = list(validate), model = model_frame$model)


test_data <- cross_d(test_data) %>%
unnest(test_training, .drop = F, .id = 'model_number') %>%
mutate(model_number = as.numeric(model_number)) %>%
left_join(data_frame(model_number = c(1:4), model_name = c('simple','medium', 'more','woah')), by = 'model_number')

test_data
```


In a few lines of code, we now have "tidy" cross validation routine across multiple models, not bad.


```{r}

test_data <- test_data %>%
mutate(fit = map2(model, train, ~lm(.x, data = .y))) %>%
mutate(root_mean_sq_error = map2_dbl(fit, test, rmse))

test_data
```


```{r}

test_data %>%
ggplot(aes(root_mean_sq_error, fill = model_name)) +
geom_density(alpha = 0.75) +
labs(x = 'Root Mean Squared Error', title = 'Cross-validated distribution of RMSE')


```

## Miscellaneos `purrr`

That's a broad tour of the key features of `purrr`. Here's a few more examples of miscellaneous things you can do with `purrr`


### `safely`

One annoying thing about using `map` (or `apply`) in place of loops is that it can make debugging much harder to deal with. With a loop, it can be a lot easier to see where exactly an error occured and your loop failed (e.g. look at the index of the loop when the error occured). With `map`, it can be much harder to figure out where the problem is, especially if you have a very large object. 

The `safely` function let's us solve this problem. 

Suppose that you've got a bunch of csv's of fish lengths from a field site. The field techs are supposed to enter the length in one column, and the units in a second column. As tends to happen though, someone put the units next to the length in one entry (e.g. 26cm). How do we deal with that?

```{r}


fish_foo <- function(){
  
  bad_tech <- ifelse(runif(1,0,10) > 2, FALSE, TRUE)
                     
  if (bad_tech == F)
  {
   lengths <- rnorm(10,25,5) %>% signif(3)
   
   units = 'cm'
  } else {
   lengths <-  paste0(rnorm(10,25,5) %>% signif(3),'cm')
   
   units <- "what's this column for?"
  }

  out <- data_frame(lengths = lengths, units = units)
  return(out)
}

length_data <-  rerun(100, fish_foo()) %>% 
  set_names(paste0('tech',1:100))

listviewer::jsonedit(length_data)

```

Our goal is to put all of these observations together, log transform the lengths, and plot. 

```{r, eval = F}

length_data %>% 
  map(log,.$lengths)

```

Yep, that doesn't work, since `map` hit an error somewhere in there. Now, we could go through all 100 entries and see which ones are bad, or concatenate them earlier and look for NAs after conversion to type numeric, but let's see how we can use `purrr` to deal with this. 

```{r}

safe_log <-  safely(log)

diagnose_length <- length_data %>% 
  map(~safe_log(.$lengths))

head(diagnose_length,2)

```


Great, now we at least have something to work with. `safely` gives us two objects per entry: the data if it worked, and a log of the error messages. 

How do we figure out which tech's are the problem? We can use `map_lgl` to help us out here

```{r}

bad_lengths <- map_lgl(diagnose_length, ~is.null(.x$error) == F)

bad_techs <- diagnose_length %>% 
  keep(bad_lengths)

names(bad_techs)
```

I leave it to your imagination to think of how to resolve this problem, but at least we now know where the problem is. One strategy is to use the handy `possibly` function from `purrr`. This basically says try a function and return it's value if it works, otherwise return something else. 

```{r}

possibly_log <-  possibly(log, otherwise = NA)


diagnose_length <- length_data %>% 
  map(~possibly_log(.$lengths))

listviewer::jsonedit(diagnose_length)

```

### Check on factors

Factors can creep into your data, which can cause problem sometimes.  There's lot's of ways to solve this, but you can use `purrr` to efficiently check for factors, and convert them to characters in your data frame.

Let's take a look at the `gapminder` dataset, from the `gapminder` package. 

```{r}

gapminder

```

Yep, look at that, country and continent are both factors. Useful for regression, but a little dangerous to have in your raw data.

We can use `purrr` to find all the factors in our data

```{r}

gapminder %>%
map_lgl(is.factor)

```

And to convert each column that is a factor into a character, we could try `map_if`, which applies a conditional statement to each element in the list, and applies the function if the test is passed

```{r}

gapminder %>%
map_if(is.factor, as.character) %>% 
  str(2)

```

Huh well that worked, but something is weird. Our nice `gapminder` dataframe is now a list. How can we do this and keep things as a dataframe? We can use the `purrrlyr` package to do this, which has handy parallels of the functions in `purrr`, but designed to deal with and give back dataframes. 

```{r}

gapminder %>%
purrrlyr::dmap_if(is.factor, as.character) %>% 
  head()

```
 
 Much better, those pesky factors are now characters and we still have a dataframe. 

### Save all plots

Suppose you've got a large project and want to save (or print) all the plots. This often leads to a lot of copy and pasting of save commands.

Here's another solution, using `walk`. Remember, the `walk` family works the same way as the `map` family, but doesn't return anything. Rather, `walk` just produces the "side effects" of a function, e.g. saving objects to a pdf. 

I usually tag all my ggplot objects that I want to save with `_plot`

```{r}

life_v_money_plot <- gapminder %>%
ggplot(aes(gdppercap, lifeexp)) +
geom_abline(aes(slope = 1, intercept = 0))  +
geom_point() +
geom_smooth(method = 'lm')

life_v_money_plot

```


```{r}

life_v_time_plot <- gapminder %>%
ggplot(aes(year, lifeexp)) +
geom_point() +
geom_smooth(method = 'lm')

life_v_time_plot
```

Suppose I want to save both of these plots?


```{r}

plot_files <- ls()[ str_detect(ls(), '_plot')]

plot_foo <- function(x){

ggsave(paste0(x,'.pdf'), get(x), device = cairo_pdf)

}

walk(plot_files, plot_foo)

```

And just like that, I've saved PDFs of all of my plots. 


### Partial

I just really like this one. Suppose you've got something that you are copy and pasting a lot, like getting interquartile range of something.

```{r}

gapminder %>%
  summarise(
    mean_gdp = mean(gdppercap),
    lower_gdp = quantile(gdppercap, 0.25),
    upper_gdp = quantile(gdppercap, 0.75),
    mean_life = mean(lifeexp),
    lower_life = quantile(lifeexp, 0.25),
    upper_life = quantile(lifeexp, 0.75)
  )

```

Works, and in this case not hard, but still annoying to retype!

```{r}

lower = partial(quantile, probs = 0.25)

upper = partial(quantile, probs = 0.75)

gapminder %>%
  summarise(
    mean_gdp = mean(gdppercap),
    lower_gdp = lower(gdppercap),
    upper_gdp = upper(gdppercap),
    mean_life = mean(lifeexp),
    lower_life = lower(lifeexp),
    upper_life = upper(lifeexp)
  )

```


Thanks!

Go get your code `purrr`ing

<!-- ![](../Exploding-Kittens.png) -->

<!-- [The Oatmeal](theoatmeal.com) -->


